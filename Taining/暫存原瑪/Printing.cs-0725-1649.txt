using Microsoft.Msagl.Drawing;
using Microsoft.Msagl.GraphViewerGdi;
using System.Collections.Generic;
using System.Linq;

namespace Taining.Function
{
    public static class Painting
    {
        public static void DrawFlowChart(string json, GViewer gViewer)
        {
            var nodesRaw = System.Text.Json.JsonSerializer.Deserialize<List<NodeData>>(json);

            // 1. 先分類
            var greenNodes = nodesRaw.Where(n => (n.ShapeType ?? "").Trim() == "程序").ToList();
            var yellowNodes = nodesRaw.Where(n => (n.ShapeType ?? "").Trim() == "子程序").ToList();
            var whiteNodes = nodesRaw.Where(n => (n.ShapeType ?? "").Trim() == "物件").ToList();

            var graph = new Graph("流程圖");

            // 強制主流程水平（左到右）
            graph.Attr.LayerDirection = LayerDirection.LR;

            // 2. 加主流程（綠色節點）
            foreach (var n in greenNodes)
            {
                var node = graph.AddNode(n.StepId);
                node.LabelText = $"{n.StepId}\n{n.Description}\n{n.ProcessId}\n{n.Time}";
                node.Attr.FillColor = Microsoft.Msagl.Drawing.Color.LightGreen;
                node.Attr.Shape = Shape.Box;
            }

            // 3. invisible edge 串接主流程（只有沒有真實線才加）
            for (int i = 1; i < greenNodes.Count; i++)
            {
                // 判斷是否有真實連線
                string fromId = greenNodes[i - 1].StepId;
                string toId = greenNodes[i].StepId;
                bool hasRealEdge = nodesRaw.Any(n => n.StepId == fromId &&
                                                     (n.NextStepId ?? "").Split(new[] { ',', ';' }, System.StringSplitOptions.RemoveEmptyEntries)
                                                     .Select(x => x.Trim()).Contains(toId));
                if (!hasRealEdge)
                {
                    var e = graph.AddEdge(fromId, toId);
                    e.Attr.Color = Microsoft.Msagl.Drawing.Color.Transparent;
                    e.Attr.LineWidth = 3;
                    e.Attr.ArrowheadAtTarget = ArrowStyle.None;
                }
            }

            // 4. 子程序（黃色）
            foreach (var n in yellowNodes)
            {
                var node = graph.AddNode(n.StepId);
                node.LabelText = $"{n.StepId}\n{n.Description}\n{n.ProcessId}\n{n.Time}";
                node.Attr.FillColor = Microsoft.Msagl.Drawing.Color.Yellow;
                node.Attr.Shape = Shape.Box;
            }

            // 5. 物件（白色）
            foreach (var n in whiteNodes)
            {
                var node = graph.AddNode(n.StepId);
                node.LabelText = $"{n.StepId}\n{n.Description}\n{n.ProcessId}\n{n.Time}";
                node.Attr.FillColor = Microsoft.Msagl.Drawing.Color.White;
                node.Attr.Shape = Shape.Box;
            }

            // 6. 所有連線（支援多分支，逗號/分號分隔）
            foreach (var n in nodesRaw)
            {
                if (!string.IsNullOrWhiteSpace(n.NextStepId))
                {
                    var nextIds = n.NextStepId.Split(new[] { ',', ';' }, System.StringSplitOptions.RemoveEmptyEntries);
                    foreach (var nextId in nextIds)
                    {
                        graph.AddEdge(n.StepId, nextId.Trim());
                    }
                }
            }

            // 7. 指定給畫布
            gViewer.Graph = graph;
        }
    }
}
